"""
Unit tests for the Configuration Service.

This module tests all functionality of the ConfigurationService including
initialization, configuration loading, caching, validation, and error handling.
"""

import asyncio
import contextlib
import os
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest
import yaml

from benchmark.core.base import ServiceStatus
from benchmark.core.config import ExperimentConfig
from benchmark.core.exceptions import ConfigurationError, ErrorCode
from benchmark.services.configuration_service import ConfigurationService


class TestConfigurationService:
    """Test the Configuration Service functionality."""

    @pytest.fixture
    async def config_service(self):
        """Create a ConfigurationService instance for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir), cache_ttl=60)
            await service.initialize()
            yield service
            await service.shutdown()

    @pytest.fixture
    def valid_config_data(self):
        """Create valid configuration data for testing."""
        return {
            "name": "Test Experiment",
            "description": "Test configuration",
            "output_dir": "./test_results",
            "datasets": [
                {
                    "name": "test_dataset",
                    "source": "local",
                    "path": "./data/test.jsonl",
                    "max_samples": 100,
                }
            ],
            "models": [
                {
                    "name": "test_model",
                    "type": "openai_api",
                    "path": "gpt-3.5-turbo",
                    "config": {"api_key": "test_key"},
                    "max_tokens": 512,
                }
            ],
            "evaluation": {"metrics": ["accuracy", "f1_score"], "parallel_jobs": 2},
        }

    @pytest.fixture
    def invalid_config_data(self):
        """Create invalid configuration data for testing."""
        return {
            "name": "",  # Invalid: empty name
            "description": "Test configuration",
            # Missing required fields
            "datasets": [],  # Invalid: no datasets
            "models": [],  # Invalid: no models
            "evaluation": {
                "metrics": [],  # Invalid: no metrics
                "parallel_jobs": 0,  # Invalid: no parallel jobs
            },
        }

    @pytest.fixture
    def temp_config_file(self, valid_config_data):
        """Create a temporary configuration file."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as f:
            yaml.dump(valid_config_data, f, indent=2)
            temp_path = f.name

        yield Path(temp_path)

        # Cleanup
        with contextlib.suppress(OSError):
            os.unlink(temp_path)

    @pytest.mark.asyncio
    async def test_service_initialization(self):
        """Test service initialization."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))

            # Test initialization
            response = await service.initialize()

            assert response.success is True
            assert service.status == ServiceStatus.HEALTHY
            assert "initialized successfully" in response.message.lower()
            assert Path(temp_dir).exists()

            # Test shutdown
            shutdown_response = await service.shutdown()
            assert shutdown_response.success is True

    @pytest.mark.asyncio
    async def test_service_initialization_with_invalid_directory(self):
        """Test service initialization with invalid directory."""
        # Use a path that cannot be created (like root directory on Unix)
        invalid_path = Path("/root/nonexistent/config")

        service = ConfigurationService(config_dir=invalid_path)

        # This should handle the error gracefully
        response = await service.initialize()

        # Should still succeed by creating the directory
        if response.success:
            assert service.status == ServiceStatus.HEALTHY
        else:
            assert service.status == ServiceStatus.ERROR

    @pytest.mark.asyncio
    async def test_health_check_healthy(self):
        """Test health check when service is healthy."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir), cache_ttl=60)
            await service.initialize()

            health = await service.health_check()

            assert health.status == ServiceStatus.HEALTHY.value
            assert "healthy" in health.message.lower()
            assert health.checks["config_dir_exists"] is True
            assert health.checks["config_dir_readable"] is True

            await service.shutdown()

    @pytest.mark.asyncio
    async def test_health_check_with_nonexistent_directory(self):
        """Test health check when config directory doesn't exist."""
        nonexistent_dir = Path("/nonexistent/config/dir")
        service = ConfigurationService(config_dir=nonexistent_dir)
        service._set_status(ServiceStatus.HEALTHY)  # Set status manually

        health = await service.health_check()

        assert health.status == ServiceStatus.UNHEALTHY.value
        assert health.checks["config_dir_exists"] is False

    @pytest.mark.asyncio
    async def test_load_experiment_config_valid(self, config_service, temp_config_file):
        """Test loading a valid configuration."""
        config = await config_service.load_experiment_config(temp_config_file)

        assert isinstance(config, ExperimentConfig)
        assert config.name == "Test Experiment"
        assert len(config.datasets) == 1
        assert len(config.models) == 1
        assert config.datasets[0].name == "test_dataset"
        assert config.models[0].name == "test_model"

    @pytest.mark.asyncio
    async def test_load_experiment_config_file_not_found(self, config_service):
        """Test loading configuration from non-existent file."""
        nonexistent_file = Path("/nonexistent/config.yaml")

        with pytest.raises(ConfigurationError) as exc_info:
            await config_service.load_experiment_config(nonexistent_file)

        assert exc_info.value.error_code == ErrorCode.CONFIG_FILE_NOT_FOUND
        assert "not found" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_load_experiment_config_invalid_yaml(self, config_service):
        """Test loading configuration with invalid YAML."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as f:
            f.write("invalid: yaml: content: [unclosed")
            invalid_yaml_file = Path(f.name)

        try:
            with pytest.raises(ConfigurationError) as exc_info:
                await config_service.load_experiment_config(invalid_yaml_file)

            assert exc_info.value.error_code == ErrorCode.CONFIG_PARSE_ERROR
            assert "invalid yaml" in str(exc_info.value).lower()

        finally:
            os.unlink(invalid_yaml_file)

    @pytest.mark.asyncio
    async def test_load_experiment_config_empty_file(self, config_service):
        """Test loading configuration from empty file."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as f:
            f.write("")  # Empty file
            empty_file = Path(f.name)

        try:
            with pytest.raises(ConfigurationError) as exc_info:
                await config_service.load_experiment_config(empty_file)

            assert exc_info.value.error_code == ErrorCode.CONFIG_PARSE_ERROR
            assert "empty" in str(exc_info.value).lower()

        finally:
            os.unlink(empty_file)

    @pytest.mark.asyncio
    async def test_load_experiment_config_validation_error(
        self, config_service, invalid_config_data
    ):
        """Test loading configuration that fails validation."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as f:
            yaml.dump(invalid_config_data, f, indent=2)
            invalid_config_file = Path(f.name)

        try:
            with pytest.raises(ConfigurationError) as exc_info:
                await config_service.load_experiment_config(invalid_config_file)

            assert exc_info.value.error_code == ErrorCode.CONFIG_VALIDATION_FAILED
            assert "validation failed" in str(exc_info.value).lower()

        finally:
            os.unlink(invalid_config_file)

    @pytest.mark.asyncio
    async def test_configuration_caching(self, config_service, temp_config_file):
        """Test configuration caching functionality."""
        # First load - should cache
        config1 = await config_service.load_experiment_config(temp_config_file)

        # Check that it's cached
        config_id = config_service._get_config_id(temp_config_file)
        cached_config = config_service.get_cached_config(config_id)

        assert cached_config is not None
        assert cached_config.name == config1.name

        # Second load - should use cache
        config2 = await config_service.load_experiment_config(temp_config_file)

        # Should be the same object (from cache)
        # Both configs should have the same content (may be same object from cache)
        assert config1.name == config2.name

    @pytest.mark.asyncio
    async def test_cache_expiration(self, config_service, temp_config_file):
        """Test cache expiration functionality."""
        # Create service with very short cache TTL
        with tempfile.TemporaryDirectory() as temp_dir:
            short_cache_service = ConfigurationService(
                config_dir=Path(temp_dir),
                cache_ttl=1,  # 1 second TTL
            )
            await short_cache_service.initialize()

            try:
                # Load configuration
                await short_cache_service.load_experiment_config(temp_config_file)
                config_id = short_cache_service._get_config_id(temp_config_file)

                # Should be cached
                cached_config = short_cache_service.get_cached_config(config_id)
                assert cached_config is not None

                # Wait for cache to expire
                await asyncio.sleep(2)

                # Should no longer be cached
                expired_config = short_cache_service.get_cached_config(config_id)
                assert expired_config is None

            finally:
                await short_cache_service.shutdown()

    @pytest.mark.asyncio
    async def test_get_default_config(self, config_service):
        """Test getting default configuration."""
        default_config = await config_service.get_default_config()

        assert isinstance(default_config, dict)
        assert "name" in default_config
        assert "datasets" in default_config
        assert "models" in default_config
        assert "evaluation" in default_config

        # Validate that default config is actually valid
        validated_config = ExperimentConfig(**default_config)
        assert validated_config.name == "Default Cybersecurity Experiment"

    @pytest.mark.asyncio
    async def test_validate_config_no_warnings(self, config_service, valid_config_data):
        """Test configuration validation with no warnings."""
        config = ExperimentConfig(**valid_config_data)
        warnings = await config_service.validate_config(config)

        # Should have some warnings due to missing files, but structure is valid
        assert isinstance(warnings, list)

    @pytest.mark.asyncio
    async def test_validate_config_with_warnings(self, config_service):
        """Test configuration validation with warnings."""
        # Create config with potential warning conditions
        config_data = {
            "name": "  ",  # Whitespace only name
            "description": "Test",
            "output_dir": "",  # Empty output dir
            "datasets": [
                {
                    "name": "tiny_dataset",
                    "source": "local",
                    "path": "/nonexistent/file.jsonl",
                    "max_samples": 5,  # Very small
                    "test_split": 0.6,  # Large split
                    "validation_split": 0.5,  # Total > 100%
                }
            ],
            "models": [
                {
                    "name": "large_model",
                    "type": "openai_api",
                    "path": "gpt-4",
                    "config": {},  # No API key
                    "max_tokens": 8000,  # Very large
                }
            ],
            "evaluation": {
                "metrics": ["accuracy"],
                "parallel_jobs": 1000,  # More than CPU count
                "timeout_minutes": 2,  # Very short
                "batch_size": 256,  # Large batch
            },
        }

        config = ExperimentConfig(**config_data)
        warnings = await config_service.validate_config(config)

        assert len(warnings) > 0

        # Check for expected warnings
        assert any("name" in w.lower() for w in warnings)
        assert any("file not found" in w.lower() for w in warnings)
        assert any("small sample size" in w.lower() for w in warnings)
        assert any("api key" in w.lower() for w in warnings)

    @pytest.mark.asyncio
    async def test_reload_config(self, config_service, temp_config_file):
        """Test configuration reloading."""
        # First load
        await config_service.load_experiment_config(temp_config_file)
        config_id = config_service._get_config_id(temp_config_file)

        # Verify it's cached
        assert config_service.get_cached_config(config_id) is not None

        # Reload
        response = await config_service.reload_config(config_id)

        assert response.success is True
        assert "marked for reload" in response.message.lower()

        # Should no longer be cached
        assert config_service.get_cached_config(config_id) is None

    @pytest.mark.asyncio
    async def test_reload_nonexistent_config(self, config_service):
        """Test reloading non-existent configuration."""
        response = await config_service.reload_config("nonexistent_id")

        assert response.success is False
        assert "not found in cache" in response.message.lower()

    @pytest.mark.asyncio
    async def test_list_cached_configs(self, config_service, temp_config_file):
        """Test listing cached configurations."""
        # Load a configuration to cache it
        await config_service.load_experiment_config(temp_config_file)

        cached_configs = await config_service.list_cached_configs()

        assert len(cached_configs) >= 1

        # Check structure of returned data
        for _config_id, metadata in cached_configs.items():
            assert "experiment_name" in metadata
            assert "cached_at" in metadata
            assert "age_seconds" in metadata
            assert "is_expired" in metadata
            assert "models_count" in metadata
            assert "datasets_count" in metadata

    @pytest.mark.asyncio
    async def test_clear_cache(self, config_service, temp_config_file):
        """Test clearing the configuration cache."""
        # Load configuration to populate cache
        await config_service.load_experiment_config(temp_config_file)
        config_id = config_service._get_config_id(temp_config_file)

        # Verify it's cached
        assert config_service.get_cached_config(config_id) is not None

        # Clear cache
        response = await config_service.clear_cache()

        assert response.success is True
        assert "cleared" in response.message.lower()

        # Verify cache is empty
        assert config_service.get_cached_config(config_id) is None

    @pytest.mark.asyncio
    async def test_save_config(self, config_service, valid_config_data):
        """Test saving configuration to disk."""
        config = ExperimentConfig(**valid_config_data)

        with tempfile.TemporaryDirectory() as temp_dir:
            save_path = Path(temp_dir) / "saved_config.yaml"

            response = await config_service.save_config(config, save_path)

            assert response.success is True
            assert save_path.exists()

            # Verify saved content
            with open(save_path) as f:
                saved_data = yaml.safe_load(f)

            assert saved_data["name"] == "Test Experiment"

    @pytest.mark.asyncio
    async def test_save_config_creates_directory(self, config_service, valid_config_data):
        """Test that save_config creates directories as needed."""
        config = ExperimentConfig(**valid_config_data)

        with tempfile.TemporaryDirectory() as temp_dir:
            nested_path = Path(temp_dir) / "nested" / "directories" / "config.yaml"

            response = await config_service.save_config(config, nested_path)

            assert response.success is True
            assert nested_path.exists()
            assert nested_path.parent.exists()

    @pytest.mark.asyncio
    async def test_thread_safety(self, config_service, temp_config_file):
        """Test thread-safe access to configurations."""
        import concurrent.futures

        def load_config():
            """Load configuration in a separate thread."""
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                return loop.run_until_complete(
                    config_service.load_experiment_config(temp_config_file)
                )
            finally:
                loop.close()

        # Load configuration concurrently from multiple threads
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(load_config) for _ in range(10)]

            # All should succeed
            results = []
            for future in concurrent.futures.as_completed(futures):
                try:
                    result = future.result(timeout=30)
                    results.append(result)
                except Exception as e:
                    pytest.fail(f"Thread safety test failed: {e}")

        # All results should be valid ExperimentConfig objects
        assert len(results) == 10
        for result in results:
            assert isinstance(result, ExperimentConfig)
            assert result.name == "Test Experiment"

    @pytest.mark.asyncio
    async def test_config_id_generation(self, config_service):
        """Test configuration ID generation."""
        path1 = Path("/some/path/config.yaml")
        path2 = Path("/some/path/config.yaml")  # Same path
        path3 = Path("/different/path/config.yaml")  # Different path

        id1 = config_service._get_config_id(path1)
        id2 = config_service._get_config_id(path2)
        id3 = config_service._get_config_id(path3)

        # Same paths should generate same IDs
        assert id1 == id2

        # Different paths should generate different IDs
        assert id1 != id3

        # IDs should be strings
        assert isinstance(id1, str)
        assert len(id1) > 0

    @pytest.mark.asyncio
    async def test_service_shutdown_clears_cache(self, temp_config_file):
        """Test that service shutdown clears the cache."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))
            await service.initialize()

            # Load and cache a configuration
            await service.load_experiment_config(temp_config_file)
            config_id = service._get_config_id(temp_config_file)

            # Verify it's cached
            assert service.get_cached_config(config_id) is not None

            # Shutdown service
            await service.shutdown()

            # Cache should be cleared
            assert len(service._cache) == 0
            assert len(service._cache_timestamps) == 0
            assert service.status == ServiceStatus.STOPPED


class TestConfigurationServiceErrors:
    """Test error handling in Configuration Service."""

    @pytest.mark.asyncio
    async def test_initialize_error_handling(self):
        """Test error handling during initialization."""
        # This test simulates an initialization error
        with patch.object(Path, "mkdir", side_effect=PermissionError("Access denied")):
            service = ConfigurationService(config_dir=Path("/protected/path"))

            response = await service.initialize()

            # Should handle the error gracefully
            assert response.success is False
            assert service.status == ServiceStatus.ERROR

    @pytest.mark.asyncio
    async def test_health_check_error_handling(self):
        """Test error handling in health check."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))
            await service.initialize()

            # Simulate an error by corrupting the service state
            original_config_dir = service.config_dir
            service.config_dir = None  # This will cause an error

            health = await service.health_check()

            assert health.status == ServiceStatus.ERROR.value
            assert "error" in health.checks

            # Restore original state
            service.config_dir = original_config_dir
            await service.shutdown()

    @pytest.mark.asyncio
    async def test_cache_operation_error_handling(self):
        """Test error handling in cache operations."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))
            await service.initialize()

            # Test clearing cache with error
            with patch.object(service, "_cache_lock", side_effect=Exception("Lock error")):
                response = await service.clear_cache()

                assert response.success is False
                assert "error" in response.message.lower()

            await service.shutdown()

    @pytest.mark.asyncio
    async def test_load_config_unexpected_error(self):
        """Test handling of unexpected errors during config loading."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))
            await service.initialize()

            # Create a temp config file
            valid_config_data = {
                "name": "Test Experiment",
                "description": "Test configuration",
                "output_dir": "./test_results",
                "datasets": [
                    {
                        "name": "test_dataset",
                        "source": "local",
                        "path": "./data/test.jsonl",
                        "max_samples": 100,
                    }
                ],
                "models": [
                    {
                        "name": "test_model",
                        "type": "openai_api",
                        "path": "gpt-3.5-turbo",
                        "config": {"api_key": "test_key"},
                        "max_tokens": 512,
                    }
                ],
                "evaluation": {"metrics": ["accuracy", "f1_score"], "parallel_jobs": 2},
            }

            with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as f:
                yaml.dump(valid_config_data, f, indent=2)
                temp_config_file = Path(f.name)

            try:
                # Simulate unexpected error during YAML loading
                with patch("yaml.safe_load", side_effect=Exception("Unexpected error")):
                    with pytest.raises(ConfigurationError) as exc_info:
                        await service.load_experiment_config(temp_config_file)

                    assert exc_info.value.error_code == ErrorCode.INTERNAL_ERROR
                    assert "unexpected error" in str(exc_info.value).lower()
            finally:
                os.unlink(temp_config_file)

            await service.shutdown()

    @pytest.mark.asyncio
    async def test_save_config_error_handling(self):
        """Test error handling when saving configuration fails."""
        with tempfile.TemporaryDirectory() as temp_dir:
            service = ConfigurationService(config_dir=Path(temp_dir))
            await service.initialize()

            valid_config_data = {
                "name": "Test Experiment",
                "description": "Test configuration",
                "output_dir": "./test_results",
                "datasets": [
                    {
                        "name": "test_dataset",
                        "source": "local",
                        "path": "./data/test.jsonl",
                        "max_samples": 100,
                    }
                ],
                "models": [
                    {
                        "name": "test_model",
                        "type": "openai_api",
                        "path": "gpt-3.5-turbo",
                        "config": {"api_key": "test_key"},
                        "max_tokens": 512,
                    }
                ],
                "evaluation": {"metrics": ["accuracy", "f1_score"], "parallel_jobs": 2},
            }
            config = ExperimentConfig(**valid_config_data)

            # Try to save to a path that will cause an error
            with patch("builtins.open", side_effect=PermissionError("Permission denied")):
                response = await service.save_config(config, Path("/protected/config.yaml"))

                assert response.success is False
                assert "failed to save" in response.message.lower()

            await service.shutdown()


@pytest.mark.asyncio
async def test_configuration_service_integration():
    """Integration test for Configuration Service."""
    with tempfile.TemporaryDirectory() as temp_dir:
        config_dir = Path(temp_dir)

        # Create service
        service = ConfigurationService(config_dir=config_dir, cache_ttl=30)

        try:
            # Initialize
            init_response = await service.initialize()
            assert init_response.success is True

            # Check health
            health = await service.health_check()
            assert health.status == ServiceStatus.HEALTHY.value

            # Get default config
            default_config = await service.get_default_config()
            resolved_config = service.resolve_environment_variables(default_config)
            validated_config = ExperimentConfig(**resolved_config)

            # Save config
            config_file = config_dir / "test_config.yaml"
            save_response = await service.save_config(validated_config, config_file)
            assert save_response.success is True

            # Load saved config
            loaded_config = await service.load_experiment_config(config_file)
            assert loaded_config.name == validated_config.name

            # Validate config
            warnings = await service.validate_config(loaded_config)
            assert isinstance(warnings, list)

            # List cached configs
            cached_configs = await service.list_cached_configs()
            assert len(cached_configs) >= 1

            # Clear cache
            clear_response = await service.clear_cache()
            assert clear_response.success is True

        finally:
            # Shutdown
            shutdown_response = await service.shutdown()
            assert shutdown_response.success is True
